{
  "version": 3,
  "sources": ["../../ol/transform.js", "../../ol/render/EventType.js", "../../ol/layer/Property.js", "../../ol/layer/Base.js", "../../ol/layer/Layer.js", "../../ol/renderer/Layer.js", "../../ol/render/Event.js", "../../ol/color.js", "../../ol/renderer/canvas/Layer.js"],
  "sourcesContent": ["/**\n * @module ol/transform\n */\nimport {WORKER_OFFSCREEN_CANVAS} from './has.js';\nimport {assert} from './asserts.js';\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3Ã—3 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {Transform}\n */\nconst tmp_ = new Array(6);\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n  const a1 = transform1[0];\n  const b1 = transform1[1];\n  const c1 = transform1[2];\n  const d1 = transform1[3];\n  const e1 = transform1[4];\n  const f1 = transform1[5];\n  const a2 = transform2[0];\n  const b2 = transform2[1];\n  const c2 = transform2[2];\n  const d2 = transform2[3];\n  const e2 = transform2[4];\n  const f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n  return set(target, x, 0, 0, y, 0, 0);\n}\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  const sin = Math.sin(angle);\n  const cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n  return makeInverse(source, source);\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n  const det = determinant(source);\n  assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  const a = source[0];\n  const b = source[1];\n  const c = source[2];\n  const d = source[3];\n  const e = source[4];\n  const f = source[5];\n\n  target[0] = d / det;\n  target[1] = -b / det;\n  target[2] = -c / det;\n  target[3] = a / det;\n  target[4] = (c * f - d * e) / det;\n  target[5] = -(a * f - b * e) / det;\n\n  return target;\n}\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n/**\n * @type {HTMLElement}\n * @private\n */\nlet transformStringDiv;\n\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n  const transformString = 'matrix(' + mat.join(', ') + ')';\n  if (WORKER_OFFSCREEN_CANVAS) {\n    return transformString;\n  }\n  const node =\n    transformStringDiv || (transformStringDiv = document.createElement('div'));\n  node.style.transform = transformString;\n  return node.style.transform;\n}\n", "/**\n * @module ol/render/EventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered before a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#prerender\n   * @api\n   */\n  PRERENDER: 'prerender',\n\n  /**\n   * Triggered after a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#postrender\n   * @api\n   */\n  POSTRENDER: 'postrender',\n\n  /**\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#precompose\n   * @api\n   */\n  PRECOMPOSE: 'precompose',\n\n  /**\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#postcompose\n   * @api\n   */\n  POSTCOMPOSE: 'postcompose',\n\n  /**\n   * Triggered when rendering is complete, i.e. all sources and tiles have\n   * finished loading for the current viewport, and all tiles are faded in.\n   * The event object will not have a `context` set.\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\n   * @api\n   */\n  RENDERCOMPLETE: 'rendercomplete',\n};\n\n/**\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\n */\n\n/**\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\n */\n", "/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n", "/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = Object.assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      Object.assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: managed === undefined ? true : managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [background] Background color.\n   */\n  setBackground(background) {\n    this.background_ = background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 64); // Layer opacity must be a number\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n", "/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport {assert} from '../asserts.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:source', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:source'|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../Map.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array ? array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    states = states ? states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? 'undefined' : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this\n      );\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return new Promise((resolve) => resolve([]));\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../Map.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        function (evt) {\n          const renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\n          const layerState = this.getLayerState(false);\n          // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.\n          assert(\n            !layerStatesArray.some(function (arrayLayerState) {\n              return arrayLayerState.layer === layerState.layer;\n            }),\n            67\n          );\n          layerStatesArray.push(layerState);\n        },\n        this\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType|null} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n", "/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n", "/**\n * @module ol/render/Event\n */\n\nimport Event from '../events/Event.js';\n\nclass RenderEvent extends Event {\n  /**\n   * @param {import(\"./EventType.js\").default} type Type.\n   * @param {import(\"../transform.js\").Transform} [inversePixelTransform] Transform for\n   *     CSS pixels to rendered pixels.\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.\n   */\n  constructor(type, inversePixelTransform, frameState, context) {\n    super(type);\n\n    /**\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\n     * @type {import(\"../transform.js\").Transform|undefined}\n     * @api\n     */\n    this.inversePixelTransform = inversePixelTransform;\n\n    /**\n     * An object representing the current render frame state.\n     * @type {import(\"../Map.js\").FrameState|undefined}\n     * @api\n     */\n    this.frameState = frameState;\n\n    /**\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\n     * context.\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\n     * @api\n     */\n    this.context = context;\n  }\n}\n\nexport default RenderEvent;\n", "/**\n * @module ol/color\n */\nimport {assert} from './asserts.js';\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return toString(color);\n  }\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  } else {\n    return '';\n  }\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = (function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  const MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  const cache = {};\n\n  /**\n   * @type {number}\n   */\n  let cacheSize = 0;\n\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      let color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          let i = 0;\n          for (const key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n})();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return fromString(color);\n  }\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.startsWith('rgba(')) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.startsWith('rgb(')) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    assert(false, 14); // Invalid color\n  }\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');\n}\n", "/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext = canvas.getContext('2d');\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor)\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n"],
  "mappings": "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",
  "names": ["EventType_default", "EventType_default", "Layer_default", "Event_default", "toString", "Layer_default", "Event_default", "EventType_default"]
}
